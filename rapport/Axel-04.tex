\chapter[Commandes internes]{Traiter les commandes internes}
Il est temps de s'occuper des commandes internes. La stratégie ? On va avoir une liste de ces commandes, dans le cas d'une commande SIMPLE, on compare la commande dans l'arbre avec les éléments de notre liste, on récupère son indice et on switch / case. Rien de compliqué. On aura ensuite une fonction par commande. À la fin de notre liste, j'ajoute un NULL pour détecter facilement la fin (tant que non NULL...). D'ailleurs, erreur que j'ai commise, c'est de faire if(strcmp(...)). strcmp retourne 0 en cas d'égalité, et 0... veut dire false. L'habitude qu'un programme retourne 0 en cas de succès, et un code d'erreur sinon. Du coup, forcément, mes commandes internes n'étaient pas bien traitées. Pour les commandes internes, par ailleurs, on ne traitera que les cas les plus standards. Je suppose que l'objectif n'est aps de les coder entièrement (c'est plus long que difficile). Par exemple, pour la commande kill, on ne traitera que le cas "kill <pid1> <pid2>...". Faisons une liste des traitements :
\\\begin{itemize}
\item[echo :] afficher les arguments sur la sortie standard ;
\\\item[date :] en utilisant time() et localtime(), on peut obtenir toutes les informations dont on a besoin, puis l'afficher correctement. Pour l'instant on reste sur un affichage simple, pas d'options comme la commande d'origine. Pour avoir le fuseau horaire, on compare le localtime() avec le gmtime(), et ensuite ce n'est que de la mise en forme ;
\\\item[exit :] je m'en occupe maintenant, car j'en ai marre de quitter le mini-shell avec un C-c. C'est simplement un exit(0) ;
\\\item[pwd :] on va utiliser getcwd(NULL, 0) qui a l'avantage d'utiliser malloc, et donc de ne pas avoir de limite de taille de buffer (même si 1024 serait certainement suffisant). Il faut juste qu'on free() ce buffer juste après l'affichage ;
\\\item[cd :] il semblerait de la fonction chdir() fasse le boulot. Seuls "problèmes" : "cd" seul est équivalent à "cd \textasciitilde", et "cd -" doit revenir en arrière. Oh ! "cd \textasciitilde" renvoie un Syntax error. Bon, pas besoin de le faire du coup, je suppose (on va pas modifier l'analyseur quand même, si ?). Du coup, je suppose de même avec "cd -" (il faudrait juste stocker le buffer donné par pwd, et s'en resservir dans chdir) ;
\\\item[history :] le programme possède déjà un système d'historique (haut et bas permettent de se déplacer dedans). Toutes les commandes sont donc forcément enregistrées quelque part ; il suffit de les trouver, et de les afficher. L'historique semble être une liste de HIST\_ENTRY, pointeur sur une structure contenant une ligne, qui doit être la commande. On devrait donc utiliser les fonctions history\_get() qui nous renvoie une de ces structures, et where\_history() pour savoir jusqu'où nous devons afficher l'historique (position actuelle). Pour l'affichage, je conserve ce qui se fait avec la commande history habituellement : 5 colonnes pour le nombre, deux espaces, puis la commande. La commande de base s'adapte sûrement à la largeur des nombres, mais ici, il est peu probable qu'on dépasse les 99'999 commandes exécutées ;
\\\item[hostname :] il existe la fonction gethostname() qui fait le job. On lui donne un buffer de 1024 caractères (qui devraient suffire), et on ajoute, au cas-où, un '\textbackslash{0}' à la fin, car si le nom était trop long et a été tronqué, le '\textbackslash{0}' de fin est tronqué aussi ;
\\\item[kill :] on a la fonction kill(). Le signal par défaut utilisé est SIGTERM, signal 15. On vérifie que tous les paramètres sont des nombres, puis on applique kill() sur chacun d'eux.
\\\end{itemize}
Voilà pour les commandes internes. À ce stade, il nous reste "remote", qui s'annonce quelque peu tiré par les cheveux.
\\\\
\textbf{> Get inside of the party !}